import asyncio
import logging
from datetime import datetime
from pathlib import Path
import configparser
import pandas as pd
import numpy as np
from binance.client import Client
from ema_vwap import calculate_indicators

# Load config
CFG_FILE = Path("config.ini")
if not CFG_FILE.exists():
    raise FileNotFoundError("config.ini not found")

config = configparser.ConfigParser()
config.read(CFG_FILE)

TRADING = config["TRADING"]
STRATEGY = config["STRATEGY"]

SYMBOL = TRADING.get("SYMBOL", "BTCUSDT")
TFRAME = TRADING.get("trade_interval", "5m")
ENTRY_USDT = float(TRADING.get("entry_usdt", 100))
TP_PCT = float(TRADING.get("tp_percentage", 0.8))
SL_PCT = float(TRADING.get("sl_percentage", 0.8))
SLEEP_MINUTES = int(TRADING.get("sleep_time", 5))
TP_SL_INTERVAL = int(TRADING.get("tp_sl_check_interval", 10))

EMA_SPAN = int(STRATEGY.get("ema_span", 21))
VWAP_BUFFER = float(STRATEGY.get("vwap_buffer", 0.001))
RSI_GATE = int(STRATEGY.get("rsi_gate", 50))

STOCH_OVERBOUGHT = int(STRATEGY.get("stoch_k_overbought", 70))
STOCH_OVERSOLD = int(STRATEGY.get("stoch_k_oversold", 30))

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(message)s")

client = Client("", "", testnet=False)

# Global state for the position
current_position = None
entry_price = 0
entry_time = None
balance = ENTRY_USDT
entry_quantity = 0


def fetch_latest_data(symbol: str, interval: str, limit=20):
    klines = client.get_klines(symbol=symbol, interval=interval, limit=limit)
    df = pd.DataFrame(klines, columns=[
        'timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time',
        'quote_volume', 'trades_count', 'taker_buy_volume', 'taker_buy_quote_volume', 'ignore'])
    for col in ['open', 'high', 'low', 'close', 'volume']:
        df[col] = df[col].astype(float)
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    return df


def generate_signal(df):
    row = df.iloc[-1]
    price = row['close']
    if (price > row['vwap'] * (1 - VWAP_BUFFER) and row['stoch_k'] < STOCH_OVERBOUGHT and
            row['rsi'] > RSI_GATE and price > row['ema_trend']):
        return 'LONG'
    elif (price < row['vwap'] * (1 + VWAP_BUFFER) and row['stoch_k'] > STOCH_OVERSOLD and
            row['rsi'] < (100 - RSI_GATE) and price < row['ema_trend']):
        return 'SHORT'
    return None


async def tp_sl_monitor():
    global current_position, entry_price, entry_time, balance, entry_quantity
    while True:
        await asyncio.sleep(TP_SL_INTERVAL)
        if current_position is None:
            continue

        df = fetch_latest_data(SYMBOL, TFRAME, limit=2)
        current_price = df['close'].iloc[-1]

        pnl_pct = ((current_price - entry_price) / entry_price) * 100 if current_position == 'LONG' else ((entry_price - current_price) / entry_price) * 100
        profit = balance * pnl_pct / 100

        if pnl_pct >= TP_PCT:
            # Simulated take profit
            logging.info(f"TP HIT | {current_position} | Exit: {current_price} | Entry: {entry_price} | Profit: {profit:.2f} USDT | Time: {datetime.now()}")
            # CLOSE ORDER: client.futures_create_order(...)
            current_position = None
            balance += profit
        elif pnl_pct <= -SL_PCT:
            # Simulated stop loss
            logging.info(f"SL HIT | {current_position} | Exit: {current_price} | Entry: {entry_price} | Loss: {profit:.2f} USDT | Time: {datetime.now()}")
            # CLOSE ORDER: client.futures_create_order(...)
            current_position = None
            balance += profit


async def strategy_loop():
    global current_position, entry_price, entry_time, balance, entry_quantity
    while True:
        df = fetch_latest_data(SYMBOL, TFRAME, limit=20)
        df = calculate_indicators(df, ema_span=EMA_SPAN)

        signal = generate_signal(df)

        if current_position is None and signal:
            entry_price = df['close'].iloc[-1]
            entry_time = df['timestamp'].iloc[-1]
            current_position = signal
            entry_quantity = balance / entry_price
            # OPEN ORDER: client.futures_create_order(...)
            logging.info(f"OPEN {signal} | Entry: {entry_price} | USDT: {balance:.2f} | Qty: {entry_quantity:.5f} | Time: {entry_time}")

        await asyncio.sleep(SLEEP_MINUTES * 60)


async def main():
    logging.info("Starting backtest simulation loop")
    await asyncio.gather(
        strategy_loop(),
        tp_sl_monitor()
    )


if __name__ == '__main__':
    asyncio.run(main())
